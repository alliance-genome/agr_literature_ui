// import { useState, useEffect } from 'react';
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';

import RowDivider from './RowDivider';

import { BiblioSubmitUpdateRouter } from './BiblioEditor';
import { AuthorExpandToggler } from './BiblioEditor';
import { splitCurie } from './BiblioEditor';
// import { aggregateCitation } from './BiblioEditor';
import { RowDisplayReferencefiles } from '../Biblio';
import { RowDisplayResourcesForCuration } from '../BiblioRowDisplayUtils';

import { changeBiblioMeshExpandToggler } from '../../actions/biblioActions';

import Container from 'react-bootstrap/Container';
import Row from 'react-bootstrap/Row';
import Col from 'react-bootstrap/Col';
import Form from 'react-bootstrap/Form';

import { fieldsSimple, fieldsArrayString, fieldsBooleanDisplayOnly, fieldsOrdered } from './BiblioEditor';


// constants available in BiblioEditor
// import { 
//   fieldsSimple, fieldsArrayString, fieldsOrdered, fieldsPubmed, fieldsDisplayOnly, fieldsDatePublished,
//   fieldTypeDict, enumDict
// } from './BiblioEditor';


// title
// cross_references (doi, pmid, modID)
// authors (collapsed [in a list, or only first author])
// citation (generated from other fields, curators will decide later)
// abstract
//
// category
// pubmed_types
// mod_reference_types
//
// resource (resource_curie resource_title ?)
// volume
// issue_name
// page_range
//
// editors
// publisher
// language
//
// date_published
// date_arrived_in_pubmed
// date_last_modified_in_pubmed
//
// keywords
// mesh_terms

const getLabel = (name) => (name === 'category' ? 'alliance_category' : name);

export const RowDisplaySimple = ({fieldName, value, updatedFlag, extraLabelContent}) => {
    const label = getLabel(fieldName); 
    return (  <Row key={fieldName} className="Row-general" xs={2} md={4} lg={6}>
              <Col className="Col-general Col-display Col-display-left">
                {label}
                {extraLabelContent && ( <span style={{ marginLeft: '8px' }}>{extraLabelContent}</span>)}</Col>
              <Col className={`Col-general Col-display Col-display-right ${updatedFlag}`} lg={{ span: 10 }}>{value}</Col>
            </Row>); }

export const RowDisplayString = ({fieldName, referenceJsonLive, referenceJsonDb, extraLabelContent}) => {
  let valueLive = ''; let valueDb = ''; let updatedFlag = '';
  if (fieldName in referenceJsonDb) { valueDb = referenceJsonDb[fieldName] }
  if (fieldName in referenceJsonLive) { valueLive = referenceJsonLive[fieldName] }
//   if (fieldName === 'citation') {		// citation now generated by database triggers
//     valueDb = aggregateCitation(referenceJsonDb)
//     valueLive = aggregateCitation(referenceJsonLive) }
  if (valueLive !== valueDb) { updatedFlag = 'updated'; }
  let valueToDisplay = valueLive;
  if ( (fieldName === 'title') || (fieldName === 'abstract') || (fieldName === 'citation') ) {
    valueToDisplay = (<span dangerouslySetInnerHTML={{__html: valueLive}} />) }
  return (
        <RowDisplaySimple key={fieldName} fieldName={fieldName} value={valueToDisplay} updatedFlag={updatedFlag} extraLabelContent={extraLabelContent} />); }

const RowDisplayArrayString = ({fieldIndex, fieldName, referenceJson, referenceJsonLive, referenceJsonDb}) => {
  if (fieldName in referenceJsonLive && referenceJsonLive[fieldName] !== null) {	// need this because referenceJsonLive starts empty before values get added
    const rowArrayStringElements = []
    if (referenceJsonLive[fieldName].length === 0) {
      rowArrayStringElements.push(<RowDisplaySimple key={fieldName} fieldName={fieldName} value="" updatedFlag="" />); }
    else {
      for (const [index, valueLive] of referenceJsonLive[fieldName].entries()) {
        let valueDb = ''; let updatedFlag = '';
        if (typeof referenceJsonDb[fieldName][index] !== 'undefined') { valueDb = referenceJsonDb[fieldName][index] }
        if (valueLive !== valueDb) { updatedFlag = 'updated'; }
        rowArrayStringElements.push(<RowDisplaySimple key={`${fieldIndex} ${index}`} fieldName={fieldName} value={valueLive} updatedFlag={updatedFlag} />); } }
    return (<>{rowArrayStringElements}</>); }
  else { return null; } }

const RowDisplayModAssociation = ({fieldIndex, fieldName, referenceJsonLive, referenceJsonDb}) => {
//   fieldName = 'mod_corpus_associations';
  if ('mod_corpus_associations' in referenceJsonLive && referenceJsonLive['mod_corpus_associations'] !== null) {
    const rowModAssociationElements = []
    for (const[index, modAssociationDict] of referenceJsonLive['mod_corpus_associations'].entries()) {
      let valueLiveMod = modAssociationDict['mod_abbreviation']; let valueDbMod = ''; let updatedFlagMod = '';
      let valueLiveCorpus = modAssociationDict['corpus']; let valueDbCorpus = ''; let updatedFlagCorpus = '';
      let valueLiveSource = modAssociationDict['mod_corpus_sort_source']; let valueDbSource = ''; let updatedFlagSource = '';

        if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
             (typeof referenceJsonDb[fieldName][index]['mod_abbreviation'] !== 'undefined') ) {
               valueDbMod = referenceJsonDb[fieldName][index]['mod_abbreviation'] }
        if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
             (typeof referenceJsonDb[fieldName][index]['corpus'] !== 'undefined') ) {
               valueDbCorpus = referenceJsonDb[fieldName][index]['corpus'] }
        if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
             (typeof referenceJsonDb[fieldName][index]['mod_corpus_sort_source'] !== 'undefined') ) {
               valueDbSource = referenceJsonDb[fieldName][index]['mod_corpus_sort_source'] }
        if (valueLiveMod !== valueDbMod) { updatedFlagMod = 'updated'; }
        if (valueLiveCorpus !== valueDbCorpus) { updatedFlagCorpus = 'updated'; }
        if (valueLiveSource !== valueDbSource) { updatedFlagSource = 'updated'; }

        rowModAssociationElements.push(
          <Row key={`${fieldIndex} ${index}`} className="Row-general" xs={2} md={4} lg={6}>
            <Col className="Col-general Col-display Col-display-left">mod_corpus_associations</Col>
            <Col className={`Col-general Col-display ${updatedFlagMod} `} lg={{ span: 2 }}>{valueLiveMod}</Col>
            <Col className={`Col-general Col-display ${updatedFlagCorpus} `} lg={{ span: 4 }}>{valueLiveCorpus}</Col>
            <Col className={`Col-general Col-display Col-display-right ${updatedFlagSource} `} lg={{ span: 4 }}>{valueLiveSource}</Col>
          </Row>);
      } // if (enumDict['mods'].includes(valueLiveCuriePrefix))
    return (<>{rowModAssociationElements}</>); }
  else { return null; } }


export const RowDisplayCrossReferences = ({fieldIndex, fieldName, referenceJsonLive, referenceJsonDb}) => {
  if ('cross_references' in referenceJsonLive && referenceJsonLive['cross_references'] !== null) {
    let anyUpdatedFlag = ''; let xref_list = '';
    for (const[index, crossRefDict] of referenceJsonLive['cross_references'].entries()) {
      let url = crossRefDict['url'];
      let valueLiveCurie = crossRefDict['curie']; let valueDbCurie = ''; let updatedFlagCurie = '';
      let valueLiveIsObsolete = crossRefDict['is_obsolete']; let valueDbIsObsolete = ''; let updatedFlagIsObsolete = '';
      if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
           (typeof referenceJsonDb[fieldName][index]['curie'] !== 'undefined') ) {
             valueDbCurie = referenceJsonDb[fieldName][index]['curie'] }
      if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
           (typeof referenceJsonDb[fieldName][index]['is_obsolete'] !== 'undefined') ) {
             valueDbIsObsolete = referenceJsonDb[fieldName][index]['is_obsolete'] }
      if (valueLiveCurie !== valueDbCurie) { updatedFlagCurie = 'updated'; }
      if (valueLiveIsObsolete !== valueDbIsObsolete) { updatedFlagIsObsolete = 'updated'; }
      let isObsolete = '';
      if ( (typeof referenceJsonLive[fieldName][index] !== 'undefined') &&
           (typeof referenceJsonLive[fieldName][index]['is_obsolete'] !== 'undefined') ) {
             if (referenceJsonLive[fieldName][index]['is_obsolete'] === true) { isObsolete = 'obsolete'; }
             else { isObsolete = ''; } }
      let updatedFlag = '';
      if ( (updatedFlagCurie === 'updated') || (updatedFlagIsObsolete === 'updated') ) { updatedFlag = 'updated'; anyUpdatedFlag = 'updated'; }

      if (
	Array.isArray(crossRefDict.pages) &&
	crossRefDict.pages.length > 0 &&
	crossRefDict.pages[0].url
      ) {
	url = crossRefDict.pages[0].url;
      }
	
      if (xref_list !== '') { xref_list += " | "; }
      xref_list += `<span style="color: red">${isObsolete}</span> <a href=${url}  rel="noreferrer noopener" target="_blank">${valueLiveCurie}</a>`;
    }
    return (
        <Row key='resources_for_curation' className="Row-general" xs={2} md={4} lg={6}>
            <Col className='Col-general Col-display Col-display-left'>cross_references</Col>
            <Col className={`Col-general Col-display Col-display-right ${anyUpdatedFlag}`} lg={{ span: 10 }}>
                <div dangerouslySetInnerHTML={{ __html: xref_list }}></div>
            </Col>
        </Row>
    ); }
  else { return null; } }


const RowDisplayReferenceRelations = ({fieldIndex, fieldName, referenceJsonLive, referenceJsonDb}) => {
  if (fieldName in referenceJsonLive && referenceJsonLive[fieldName] !== null) {
    const rowReferenceRelationsElements = []
    for (const[index, comcorDict] of referenceJsonLive[fieldName].entries()) {
      let valueLiveCurie = comcorDict['curie']; let valueDbCurie = ''; let updatedFlagCurie = '';
      const url = '/Biblio/?action=display&referenceCurie=' + valueLiveCurie
      let valueLiveType = comcorDict['type']; let valueDbType = ''; let updatedFlagType = '';
      if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
           (typeof referenceJsonDb[fieldName][index]['curie'] !== 'undefined') ) {
             valueDbCurie = referenceJsonDb[fieldName][index]['curie'] }
      if ( (typeof referenceJsonDb[fieldName][index] !== 'undefined') &&
           (typeof referenceJsonDb[fieldName][index]['type'] !== 'undefined') ) {
             valueDbType = referenceJsonDb[fieldName][index]['type'] }
      if (valueLiveCurie !== valueDbCurie) { updatedFlagCurie = 'updated'; }
      if (valueLiveType !== valueDbType) { updatedFlagType = 'updated'; }
      let updatedFlag = '';
      if ( (updatedFlagCurie === 'updated') || (updatedFlagType === 'updated') ) { updatedFlag = 'updated' }
      const comcorValue = (<div>{valueLiveType} <a href={url} rel="noreferrer noopener">{valueLiveCurie}</a></div>);
      rowReferenceRelationsElements.push(<RowDisplaySimple key={`${fieldIndex} ${index}`} fieldName={fieldName} value={comcorValue} updatedFlag={updatedFlag} />); }
    return (<>{rowReferenceRelationsElements}</>); }
  else { return null; } }


const RowDisplayModReferenceTypes = ({fieldIndex, fieldName, referenceJsonLive, referenceJsonDb}) => {
  if ('mod_reference_types' in referenceJsonLive && referenceJsonLive['mod_reference_types'] !== null) {
    const rowModReferenceTypesElements = []
    for (const[index, modRefDict] of referenceJsonLive['mod_reference_types'].entries()) {
      let valueLiveModAbbreviation = modRefDict['mod_abbreviation']; let valueDbModAbbreviation = ''; let updatedFlagModAbbreviation = '';
      let valueLiveReferenceType = modRefDict['reference_type']; let valueDbReferenceType = ''; let updatedFlagReferenceType = '';
      if (typeof referenceJsonDb[fieldName][index]['mod_abbreviation'] !== 'undefined') { valueDbModAbbreviation = referenceJsonDb[fieldName][index]['mod_abbreviation'] }
      if (typeof referenceJsonDb[fieldName][index]['reference_type'] !== 'undefined') { valueDbReferenceType = referenceJsonDb[fieldName][index]['reference_type'] }
      if (valueLiveModAbbreviation !== valueDbModAbbreviation) { updatedFlagModAbbreviation = 'updated'; }
      if (valueLiveReferenceType !== valueDbReferenceType) { updatedFlagReferenceType = 'updated'; }
      rowModReferenceTypesElements.push(
        <Row key={`${fieldIndex} ${index}`} className="Row-general" xs={2} md={4} lg={6}>
          <Col className="Col-general Col-display Col-display-left">mod_reference_types</Col>
          <Col className={`Col-general Col-display ${updatedFlagModAbbreviation} `} lg={{ span: 2 }}>{valueLiveModAbbreviation}</Col>
          <Col className={`Col-general Col-display Col-display-right ${updatedFlagReferenceType} `} lg={{ span: 8 }}>{valueLiveReferenceType}</Col>
        </Row>); }
    return (<>{rowModReferenceTypesElements}</>); }
  else { return null; } }

export const RowDisplayCopyrightLicense = ({fieldIndex, fieldName, referenceJsonLive, displayOrEditor}) => {
  const name = (referenceJsonLive['copyright_license_name'] !== null) ? referenceJsonLive['copyright_license_name'] : '';
  const url = (referenceJsonLive['copyright_license_url'] !== null) ? referenceJsonLive['copyright_license_url'] : '';
  const desc = (referenceJsonLive['copyright_license_description'] !== null) ? referenceJsonLive['copyright_license_description'] : '';
  let cssDisplayLeft = 'Col-display Col-display-left';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = ''; }
  return (
        <Row key="meshTermsText" className="Row-general" xs={2} md={4} lg={6}>
          <Col className={`Col-general ${cssDisplayLeft}  `}>copyright_license</Col>
          <Col className={`Col-general ${cssDisplayRight} `} lg={{ span: 10 }}><a href={url} title={desc} rel="noreferrer noopener" target="_blank">{name}</a></Col>
        </Row>); }

export const RowDisplayPairDataDisplayOnly = ({fieldOne, valueOne, fieldTwo, valueTwo, displayOrEditor}) => {
  let cssDisplayLeft = 'Col-display Col-display-left';
  let cssDisplay = 'Col-display';
  let cssDisplayClear = 'Col-display';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
    cssDisplay = 'Col-editor-disabled';
    cssDisplayClear = '';
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = ''; }
  return (<Row key="RowDisplayPubmedPublicationStatusDateArrivedInPubmed" className="Row-general" xs={2} md={4} lg={6}>
            <Col className={`Col-general ${cssDisplayLeft}`} >{fieldOne}</Col>
            <Col className={`Col-general ${cssDisplay}`} lg={{ span: 4 }}>{valueOne}</Col>
            <Col className={`Col-general ${cssDisplayClear}`} lg={{ span: 2 }}>{fieldTwo}</Col>
            <Col className={`Col-general ${cssDisplayRight}`} lg={{ span: 4 }}>{valueTwo}</Col>
          </Row>); }

export const RowDisplayPubmedPublicationStatusDateArrivedInPubmed = ({referenceJsonLive, displayOrEditor}) => {
  return(<RowDisplayPairDataDisplayOnly key="RowDisplayPairDataPubmedPublicationStatusDateArrivedInPubmed" fieldOne="pubmed_publication_status" valueOne={referenceJsonLive['pubmed_publication_status'] || ''} fieldTwo="date_arrived_in_pubmed" valueTwo={referenceJsonLive['date_arrived_in_pubmed'] || ''} displayOrEditor={displayOrEditor} />); }

export const RowDisplayBooleanDisplayOnly = ({fieldName, referenceJsonLive, displayOrEditor}) => {
  let cssDisplayLeft = 'Col-display Col-display-left';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = ''; }
  return (<Row key="RowDisplayPubmedPublicationStatusDateArrivedInPubmed" className="Row-general" xs={2} md={4} lg={6}>
            <Col className={`Col-general ${cssDisplayLeft}`}>{fieldName}</Col>
            <Col className={`Col-general ${cssDisplayRight}`} lg={{ span: 10 }}>{referenceJsonLive[fieldName] === true ? fieldName : ''}</Col>
          </Row>); }

export const RowDisplayDateLastModifiedInPubmedDateCreated = ({referenceJsonLive, displayOrEditor}) => {
  const date_created_object = new Date(referenceJsonLive['date_created']);
  const date_created = date_created_object.toLocaleDateString("fr-CA");
  return(<RowDisplayPairDataDisplayOnly key="RowDisplayPairDataPubmedPublicationStatusDateArrivedInPubmed" fieldOne="date_last_modified_in_pubmed" valueOne={referenceJsonLive['date_last_modified_in_pubmed'] || ''} fieldTwo="date_created" valueTwo={date_created} displayOrEditor={displayOrEditor} />); }

export const RowDisplayMeshTerms = ({fieldIndex, fieldName, referenceJsonLive, displayOrEditor}) => {
  const meshExpand = useSelector(state => state.biblio.meshExpand);
  let cssDisplayLeft = 'Col-display Col-display-left';
  let cssDisplay = 'Col-display';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
    cssDisplay = 'Col-editor-disabled';
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = ''; }
  if ('mesh_terms' in referenceJsonLive && referenceJsonLive['mesh_terms'] !== null) {

    const rowMeshTermsElements = []
    rowMeshTermsElements.push(<MeshExpandToggler key="meshExpandTogglerComponent" displayOrEditor={displayOrEditor} />);

    const sortableMeshTermElements = {};
    const meshTextArray = [];
    for (const[index, value] of referenceJsonLive['mesh_terms'].entries()) {
      let term = value['heading_term'];
      if (value['qualifier_term'] !== null) { term += ' ' + value['qualifier_term']; }
      const lcTerm = term.toLowerCase();
      if (meshExpand === 'detailed') {
        sortableMeshTermElements[lcTerm] = (
        <Row key={`${fieldIndex} ${index}`} className="Row-general" xs={2} md={4} lg={6}>
          <Col className={`Col-general ${cssDisplayLeft} `}>mesh_terms</Col>
          <Col className={`Col-general ${cssDisplay} `} lg={{ span: 5 }}>{value['heading_term']}</Col>
          <Col className={`Col-general ${cssDisplayRight} `} lg={{ span: 5 }}>{value['qualifier_term']}</Col>
        </Row>); }
      else {
        meshTextArray.push(term); } }

    if (meshExpand === 'detailed') {
      const sortedKeys = Object.keys(sortableMeshTermElements).sort();
      for (let i = 0; i < sortedKeys.length; i++) {
        rowMeshTermsElements.push(sortableMeshTermElements[sortedKeys[i]]); } }
    else {
      const meshText = (<span dangerouslySetInnerHTML={{__html: meshTextArray.sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()); }).join('; ')}} />)
      rowMeshTermsElements.push(
        <Row key="meshTermsText" className="Row-general" xs={2} md={4} lg={6}>
          <Col className={`Col-general ${cssDisplayLeft}  `}>mesh_terms</Col>
          <Col className={`Col-general ${cssDisplayRight} `} lg={{ span: 10 }}>{meshText}</Col>
        </Row>); }

    return (<>{rowMeshTermsElements}</>); }
  else { return null; } }

const MeshExpandToggler = ({displayOrEditor}) => {
  const dispatch = useDispatch();
  const meshExpand = useSelector(state => state.biblio.meshExpand);
  let cssDisplayLeft = 'Col-display Col-display-left';
//   let cssDisplay = 'Col-display';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
//     cssDisplay = 'Col-editor-disabled';
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = ''; }
  let shortChecked = '';
  let detailedChecked = '';
  if (meshExpand === 'short') { shortChecked = 'checked'; }
    else { detailedChecked = 'checked'; }
  return (
    <Row key="meshExpandTogglerRow" className="Row-general" xs={2} md={4} lg={6}>
      <Col className={`Col-general ${cssDisplayLeft}  `}>mesh_terms</Col>
      <Col className={`Col-general ${cssDisplayRight} `} lg={{ span: 10 }}>
        <Form.Check
          inline
          checked={shortChecked}
          type='radio'
          label='short'
          id='biblio-mesh-expand-toggler-short'
          onChange={(e) => dispatch(changeBiblioMeshExpandToggler(e))}
        />
        <Form.Check
          inline
          checked={detailedChecked}
          type='radio'
          label='detailed'
          id='biblio-mesh-expand-toggler-detailed'
          onChange={(e) => dispatch(changeBiblioMeshExpandToggler(e))}
        />
      </Col>
    </Row>);
} // const MeshExpandToggler

const RowDisplayAuthors = ({ fieldIndex, fieldName, referenceJsonLive, referenceJsonDb }) => {
  // e.g. orcid/affiliations PMID:24895670   affiliations PMID:24913562   out of order PMID:33766856
  const authorExpand = useSelector((state) => state.biblio.authorExpand);

  if (!('authors' in referenceJsonLive) || referenceJsonLive['authors'] === null) return null;

  const rowAuthorElements = [];
  rowAuthorElements.push(
    <AuthorExpandToggler key="authorExpandTogglerComponent" displayOrEditor="display" />
  );

  // Preserve display order by the 'order' field (1-based)
  const orderedAuthorsLive = [];
  const orderedAuthorsDb = [];

  for (const value of referenceJsonLive['authors'].values()) {
    let idx = (value?.order ?? 1) - 1;
    if (idx < 0) idx = 0; // temporary fix for fake authors have an 'order' field value of 0
    orderedAuthorsLive[idx] = value;
  }

  if (referenceJsonDb?.authors) {
    for (const value of referenceJsonDb['authors'].values()) {
      let idx = (value?.order ?? 1) - 1;
      if (idx < 0) idx = 0; // temporary fix for fake authors have an 'order' field value of 0
      orderedAuthorsDb[idx] = value;
    }
  }

  // Helper: normalize ORCID to bare id "0000-0000-0000-0000"
  const normalizeOrcidId = (raw) => {
    if (!raw) return '';
    let s = String(raw).trim().toUpperCase();
    if (s.startsWith('ORCID:')) s = s.slice('ORCID:'.length);
    return s;
  };

  if (authorExpand === 'first') {
    if (
      orderedAuthorsLive.length > 0 &&
      typeof orderedAuthorsLive[0] !== 'undefined' &&
      'name' in orderedAuthorsLive[0]
    ) {
      rowAuthorElements.push(
        <Row key="author first" className="Row-general" xs={2} md={4} lg={6}>
          <Col className="Col-general Col-display Col-display-left">first author</Col>
          <Col className="Col-general Col-display Col-display-right" lg={{ span: 10 }}>
            <div>
              <span dangerouslySetInnerHTML={{ __html: orderedAuthorsLive[0]['name'] }} />
            </div>
          </Col>
        </Row>
      );
    }
  } else if (authorExpand === 'list') {
    const authorNames = orderedAuthorsLive
      .filter((d) => typeof d !== 'undefined' && d?.name)
      .map((d) => d.name)
      .join('; ');

    rowAuthorElements.push(
      <Row key="author list" className="Row-general" xs={2} md={4} lg={6}>
        <Col className="Col-general Col-display Col-display-left">all authors</Col>
        <Col className="Col-general Col-display Col-display-right" lg={{ span: 10 }}>
          <div>
            <span dangerouslySetInnerHTML={{ __html: authorNames }} />
          </div>
        </Col>
      </Row>
    );
  } else if (authorExpand === 'detailed') {
    for (const [index, value] of orderedAuthorsLive.entries()) {
      if (typeof value === 'undefined') continue;

      let updatedFlagAuthor = '';

      // ---- ORCID (normalize to bare id for URL + comparisons) ----
      const liveOrcidId = normalizeOrcidId(value?.orcid);
      const orcidUrl = liveOrcidId ? `https://orcid.org/${liveOrcidId}` : '';

      const orcidDisplay = liveOrcidId ? `ORCID:${liveOrcidId}` : '';
      const orcidLink =
        orcidUrl === '' ? (
          <span>{orcidDisplay}</span>
        ) : (
          <a href={orcidUrl} rel="noreferrer noopener" target="_blank">
            {orcidDisplay}
          </a>
        );

      // ---- Affiliations ----
      const affiliations = [];
      const affiliationsJoined =
        Array.isArray(value?.affiliations) && value.affiliations.length > 0
          ? value.affiliations.join('')
          : '';

      if (Array.isArray(value?.affiliations) && value.affiliations !== null) {
        for (const index_aff in value.affiliations) {
          affiliations.push(
            <div key={`index_aff ${index_aff}`} className="affiliation">
              - <span dangerouslySetInnerHTML={{ __html: value.affiliations[index_aff] }} />
            </div>
          );
        }
      }

      // ---- Compare with DB to set updatedFlagAuthor ----
      const dbAuthor = orderedAuthorsDb[index];

      if (dbAuthor !== undefined) {
        const dbOrcidId = normalizeOrcidId(dbAuthor?.orcid);

        if (dbOrcidId !== liveOrcidId) updatedFlagAuthor = 'updated';
        if (dbAuthor?.name !== undefined && dbAuthor.name !== value.name) updatedFlagAuthor = 'updated';

        const dbAffJoined =
          Array.isArray(dbAuthor?.affiliations) && dbAuthor.affiliations
            ? dbAuthor.affiliations.join('')
            : '';
        if (dbAffJoined !== affiliationsJoined) updatedFlagAuthor = 'updated';
      }

      rowAuthorElements.push(
        <Row key={`author ${index}`} className="Row-general" xs={2} md={4} lg={6}>
          <Col className="Col-general Col-display Col-display-left">author {value['order']}</Col>
          <Col className={`Col-general Col-display ${updatedFlagAuthor} `} lg={{ span: 10 }}>
            <div key={`author ${index}`}>
              <span dangerouslySetInnerHTML={{ __html: value['name'] }} />
              &nbsp;{orcidLink}
              {affiliations}
            </div>
          </Col>
        </Row>
      );
    }
  }

  return <>{rowAuthorElements}</>;
}; // const RowDisplayAuthors


const MAX_EMAILS_TO_SHOW = 5;

export const RowDisplayExtractedEmails = ({ referenceJsonLive, displayOrEditor }) => {
  // read-only always, but keep same styling behavior as other display-only rows
  let cssDisplayLeft = 'Col-display Col-display-left';
  let cssDisplayRight = 'Col-display Col-display-right';
  if (displayOrEditor === 'editor') {
    cssDisplayRight = 'Col-editor-disabled';
    cssDisplayLeft = '';
  }

  const [showAll, setShowAll] = React.useState(false);

  const emailsRaw = Array.isArray(referenceJsonLive?.emails)
    ? referenceJsonLive.emails
    : [];

  // keep only not-invalidated + has email_address, then dedupe
  const emails = [];
  const seen = new Set();
  for (const e of emailsRaw) {
    const addr = (e?.email_address || '').trim();
    const invalidated = e?.date_invalidated !== null && typeof e?.date_invalidated !== 'undefined';
    if (!addr || invalidated) continue;
    const key = addr.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    emails.push(addr);
  }

  if (emails.length === 0) return null;

  const shouldTruncate = emails.length > MAX_EMAILS_TO_SHOW;
  const visible = shouldTruncate && !showAll ? emails.slice(0, MAX_EMAILS_TO_SHOW) : emails;

  return (
    <>
      <Row key="extracted_emails" className="Row-general" xs={2} md={4} lg={6}>
        <Col className={`Col-general ${cssDisplayLeft}`}>extracted emails</Col>

        <Col className={`Col-general ${cssDisplayRight}`} lg={{ span: 10 }}>
          <div>
            {visible.map((addr) => (
              <div key={addr}>
                {addr}
              </div>
            ))}

            {shouldTruncate && (
              <div style={{ marginTop: '6px' }}>
                <button
                  type="button"
                  className="btn btn-link p-0"
                  onClick={() => setShowAll((v) => !v)}
                >
                  {showAll ? 'Show less' : `Show more (${emails.length - MAX_EMAILS_TO_SHOW} more)`}
                </button>
              </div>
            )}
          </div>
        </Col>
      </Row>
    </>
  );
};


const BiblioDisplay = () => {
  const accessToken = useSelector(state => state.isLogged.accessToken);
  const referenceJsonLive = useSelector(state => state.biblio.referenceJsonLive);
  const referenceJsonDb = useSelector(state => state.biblio.referenceJsonDb);
  if (!('date_created' in referenceJsonLive)) {
    let message = 'No AGR Reference Curie found';
    if ('detail' in referenceJsonLive) { message = referenceJsonLive['detail']; }
    return(<>{message}</>); }
  const rowOrderedElements = []
  for (const [fieldIndex, fieldName] of fieldsOrdered.entries()) {
    if (fieldName === 'DIVIDER') {
      rowOrderedElements.push(<RowDivider key={fieldIndex} />); }
    else if (fieldsSimple.includes(fieldName)) {
      rowOrderedElements.push(<RowDisplayString key={fieldName} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldsArrayString.includes(fieldName)) {
      rowOrderedElements.push(<RowDisplayArrayString key={`RowDisplayArrayString ${fieldName}`} fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldsBooleanDisplayOnly.includes(fieldName)) {
      rowOrderedElements.push(<RowDisplayBooleanDisplayOnly key={`RowDisplayBooleanDisplayOnly ${fieldName}`} fieldName={fieldName} referenceJsonLive={referenceJsonLive} />); }
    else if (fieldName === 'mod_corpus_associations') {
      rowOrderedElements.push(<RowDisplayModAssociation key="RowDisplayModAssociation" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldName === 'cross_references') {
	rowOrderedElements.push(<RowDisplayCrossReferences key="RowDisplayCrossReferences" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldName === 'resources_for_curation') {
        rowOrderedElements.push(<RowDisplayResourcesForCuration key="RowDisplayResourcesForCuration" referenceJsonLive={referenceJsonLive} />); }
    else if (fieldName === 'relations') {
      rowOrderedElements.push(<RowDisplayReferenceRelations key="RowDisplayReferenceRelations" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldName === 'mod_reference_types') {
      rowOrderedElements.push(<RowDisplayModReferenceTypes key="RowDisplayModReferenceTypes" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldName === 'mesh_terms') {
      rowOrderedElements.push(<RowDisplayMeshTerms key="RowDisplayMeshTerms" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} displayOrEditor="display" />); }
    else if (fieldName === 'authors') {
      rowOrderedElements.push(
        <RowDisplayAuthors
          key="RowDisplayAuthors"
          fieldIndex={fieldIndex}
          fieldName={fieldName}
          referenceJsonLive={referenceJsonLive}
          referenceJsonDb={referenceJsonDb}
        />
      );
      rowOrderedElements.push(
        <RowDisplayExtractedEmails
          key="RowDisplayExtractedEmails"
          referenceJsonLive={referenceJsonLive}
          displayOrEditor="display"
        />
      );
    }    
    else if (fieldName === 'date_published') {
      rowOrderedElements.push(<RowDisplayString key={fieldName} fieldName={fieldName} referenceJsonLive={referenceJsonLive} referenceJsonDb={referenceJsonDb} />); }
    else if (fieldName === 'pubmed_publication_status') {
      rowOrderedElements.push(<RowDisplayPubmedPublicationStatusDateArrivedInPubmed key="RowDisplayPubmedPublicationStatusDateArrivedInPubmed" referenceJsonLive={referenceJsonLive} />); }
    else if (fieldName === 'date_last_modified_in_pubmed') {
      rowOrderedElements.push(<RowDisplayDateLastModifiedInPubmedDateCreated key="RowDisplayDateLastModifiedInPubmedDateCreated" referenceJsonLive={referenceJsonLive} />); }
    else if (fieldName === 'copyright_license_name') {
      rowOrderedElements.push(<RowDisplayCopyrightLicense key="RowDisplayCopyrightLicense" fieldIndex={fieldIndex} fieldName={fieldName} referenceJsonLive={referenceJsonLive} displayOrEditor="display" />); }
    else if (fieldName === 'referencefiles') {
      rowOrderedElements.push(<RowDisplayReferencefiles key="referencefiles" displayOrEditor="display" />); }
  } // for (const [fieldIndex, fieldName] of fieldsOrdered.entries())

  return (<Container>{ accessToken !== null && <BiblioSubmitUpdateRouter /> }{rowOrderedElements}</Container>);
} // const BiblioDisplay


export default BiblioDisplay
